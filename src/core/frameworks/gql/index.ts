import * as fs from 'fs';
import * as path from 'path';

import { ApolloClient, InMemoryCache, DocumentNode, QueryResult } from '@apollo/client';
import { at } from 'lodash';

import { getEnv } from '@config/env';
import { getConstants } from '@src/config/constants';
import {
  SecuredLine,
  GetLineArgs,
  GetLinePageArgs,
  GetLinesArgs,
  GetLineEventsArgs,
  GetUserPortfolioArgs,
  GetUserPortfolioResponse,
  QueryResponse,
  QueryCreator,
  GetLinePageResponse,
  GetLinesResponse,
  LineEventFragResponse,
  GetLineEventsResponse,
  SupportedOracleTokenResponse,
  CreditPosition,
  Network,
} from '@src/core/types';

import {
  GET_LINE_QUERY,
  GET_LINE_PAGE_QUERY,
  GET_LINE_EVENTS_QUERY,
  GET_LINES_QUERY,
  GET_SUPPORTED_ORACLE_TOKENS_QUERY,
  GET_USER_PORTFOLIO_QUERY,
} from './queries';
import { possibleTypes } from './possibleTypes.js';

const fetch = require('cross-fetch');

// TODO: GRAPH_CHAINLINK_FEED_REGISTRY_API_URL
const { GRAPH_API_URL, GRAPH_TEST_API_URL, GRAPH_CHAINLINK_FEED_REGISTRY_API_URL } = getEnv();
const { BLACKLISTED_LINES: blacklist } = getConstants();

// utility function get GRAPH_API_URL based on network parameter
export const getGraphURL = (network: string) => {
  let url = '';
  if (network === 'mainnet') {
    url = GRAPH_API_URL!;
  } else if (network === 'goerli') {
    url = GRAPH_TEST_API_URL!;
  }
  return url;
};

type PossibleTypeMap = {
  [supertype: string]: string[];
};

// Generates possibleTypes object to pass as parameter when initializing
// InMemoryCache in getClient function. Enables usage of fragments with
// unions and interfaces in GraphQL queries.
export const generateSubgraphTypes = async (url: string): Promise<PossibleTypeMap> => {
  // TODO: Add destination path for possibleTypes.js file.
  // const homeDirectory = path.resolve(process.cwd());
  // const destinationDirectory = '/src/core/frameworks/gql/possibleTypes.js';
  // const destinationPath = path.join(homeDirectory, destinationDirectory);
  // const destinationPath = path.join(homeDirectory + '/possibleTypes.js');
  // console.log('path home: ', homeDirectory);
  // console.log('path destination: ', destinationPath);
  return fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      variables: {},
      query: `
      {
        __schema {
          types {
            kind
            name
            possibleTypes {
              name
            }
          }
        }
      }
    `,
    }),
  })
    .then((result: Response) => result.json())
    .then((result: any) => {
      const generatedTypes: { [key: string]: string[] } = {};

      result.data.__schema.types.forEach((supertype: any) => {
        if (supertype.possibleTypes) {
          generatedTypes[supertype.name] = supertype.possibleTypes.map((subtype: any) => subtype.name);
        }
      });
      console.log('successful processing? ', result);
      console.log('successful processing possibleTypes? ', generatedTypes);

      // TODO: Determine why including writeFile causes the function to return an error.
      // write file of newly generated types to directory
      // fs.writeFile(
      //   destinationPath,
      //   `// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n/* eslint-disable prettier/prettier */\nexport const possibleTypes = ${JSON.stringify(
      //     generatedTypes
      //   )};`,
      //   (err) => {
      //     if (err) {
      //       console.error('Error writing possibleTypes.js', err);
      //     } else {
      //       console.log('Fragment types successfully extracted!');
      //     }
      //   }
      // );

      return generatedTypes;
    })
    .catch((error: any) => {
      console.error('Error generating subgraph types:', error);
    });
};

// Async version of getClient
// let client: any;
// export const getClient = async (network: string) => (client ? client : await createClient(network));
// // export const createClient = async (network: string): Promise<typeof ApolloClient> => {
// export const createClient = async (network: string): Promise<ApolloClient<{}>> => {
//   const graphApiUrL = getGraphURL(network);
//   console.log('GRAPH QL API URL Network: ', network);
//   console.log('GRAPH QL API URL: ', graphApiUrL);
//   const generatedSubgraphTypes = await generateSubgraphTypes(graphApiUrL);
//   client = new ApolloClient({
//     uri: graphApiUrL,
//     cache: new InMemoryCache({
//       possibleTypes: generatedSubgraphTypes ?? possibleTypes,
//     }),
//   });
//   return client;
// };

// Synchronous version of getClient
let client: any;
export const getClient = (network: string) => (client ? client : createClient(network));
// const createClient = async (network: string): Promise<typeof ApolloClient> => {
// export const createClient = (network: string): typeof ApolloClient => {
export const createClient = (network: string): ApolloClient<{}> => {
  const graphApiUrL = getGraphURL(network);
  // const generatedSubgraphTypes = await generateSubgraphTypes(graphApiUrL);
  client = new ApolloClient({
    uri: graphApiUrL,
    cache: new InMemoryCache({
      // possibleTypes: generatedSubgraphTypes ?? possibleTypes,
      possibleTypes,
    }),
  });
  return client;
};

let priceFeedClient: any;
export const getPriceFeedClient = (isOracle?: boolean) =>
  priceFeedClient ? priceFeedClient : createPriceFeedClient(isOracle);
const createPriceFeedClient = (isOracle?: boolean): typeof ApolloClient => {
  priceFeedClient = new ApolloClient({
    uri: GRAPH_CHAINLINK_FEED_REGISTRY_API_URL,
    cache: new InMemoryCache(),
  });
  return priceFeedClient;
};

/**
 * @desc - curried factory func to export funcs for each query that can be reused anywhere
 * @example - const getLine = createQuery(GET_LINE_QUERY); getLine({ id: "0x" });
 * @param query - string of graph query
 * @returns {
 *  loading?: boolean; if request has completed or not
 *  error?: object; JS error object?
 *  data?: response data formatted to submitted query
 * }
 * @dev - TODO: allow types to be passed in as args in createQuery so we dont need two lines of code for each function
 *        1. for creating curried func and 2. for defining arg/return types of that func
 */
export const createQuery =
  (query: DocumentNode, path?: string, network?: string, isOracle?: boolean): Function =>
  <A, R>(variables: A): Promise<QueryResponse<R>> =>
    new Promise(async (resolve, reject) => {
      // const client = isOracle ? getPriceFeedClient() : await getClient(network!);
      const client = isOracle ? getPriceFeedClient() : getClient(network!);
      console.log('Graph QL Client - gql/index - url: ', client.link);
      client
        .query({ query, variables })
        .then((result: QueryResult) => {
          console.log('gql result', result, query);
          const { data, error } = result;
          const requestedData = path ? at(data, [path])[0] : data;
          if (error) return reject(error);
          else return resolve(requestedData);
        })
        .catch((error: any) => {
          console.log('gql request error', error);
          reject(error);
        });
    });

const getLineQuery = createQuery(GET_LINE_QUERY);
export const getLine: QueryCreator<GetLineArgs, SecuredLine> = <GetLineArgs, SecuredLine>(
  arg: GetLineArgs
): QueryResponse<SecuredLine> => getLineQuery(arg);

const getLinePageQuery = createQuery(GET_LINE_PAGE_QUERY, 'lineOfCredit');
export const getLinePage: QueryCreator<GetLinePageArgs, GetLinePageResponse> = <GetLinePageArgs, GetLinePageResponse>(
  arg: GetLinePageArgs
): QueryResponse<GetLinePageResponse> => getLinePageQuery(arg);

const getLinesQuery = createQuery(GET_LINES_QUERY, 'lineOfCredits');
export const getLines: QueryCreator<GetLinesArgs, GetLinesResponse[]> = <GetLinesArgs, GetLinesResponse>(
  arg: GetLinesArgs
): QueryResponse<GetLinesResponse[]> => getLinesQuery({ ...arg, blacklist });

const getLineEventsQuery = createQuery(GET_LINE_EVENTS_QUERY, 'lineOfCredit');
export const getLineEvents: QueryCreator<GetLineEventsArgs, GetLineEventsResponse> = <
  GetLineEventsArgs,
  GetLineEventsResponse
>(
  arg: GetLineEventsArgs
): QueryResponse<GetLineEventsResponse> => getLineEventsQuery(arg);

const getSupportedOracleTokensQuery = createQuery(GET_SUPPORTED_ORACLE_TOKENS_QUERY, undefined, undefined, true);
export const getSupportedOracleTokens: QueryCreator<
  undefined,
  SupportedOracleTokenResponse | undefined
> = (): QueryResponse<SupportedOracleTokenResponse | undefined> => getSupportedOracleTokensQuery();

const getUserPortfolioQuery = createQuery(GET_USER_PORTFOLIO_QUERY);
export const getUserPortfolio: QueryCreator<GetUserPortfolioArgs, GetUserPortfolioResponse> = (
  arg: GetUserPortfolioArgs
) => getUserPortfolioQuery(arg);
